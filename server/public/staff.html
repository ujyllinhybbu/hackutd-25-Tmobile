<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Support Console</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        margin: 0;
        font-family: system-ui, sans-serif;
        background: #0f172a;
        color: #e5e7eb;
      }
      .wrap {
        max-width: 1100px;
        margin: 24px auto;
        padding: 0 16px;
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 16px;
      }
      .col {
        background: #0b1225;
        border: 1px solid #1e293b;
        border-radius: 14px;
        padding: 12px;
      }
      h2 {
        margin: 0 0 12px;
        font-size: 18px;
      }
      .list {
        height: 540px;
        overflow: auto;
      }
      .row {
        border: 1px solid #1e293b;
        border-radius: 10px;
        padding: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        background: #0a1122;
      }
      .row.active {
        outline: 2px solid #2563eb;
      }
      .muted {
        color: #94a3b8;
        font-size: 12px;
      }
      .count {
        font-size: 12px;
        background: #0a1122;
        border: 1px solid #1e293b;
        padding: 2px 8px;
        border-radius: 999px;
        margin-left: 6px;
      }
      .msgs {
        height: 420px;
        overflow-y: auto;
        border: 1px solid #1e293b;
        background: #09122a;
        border-radius: 12px;
        padding: 12px;
      }
      .msg {
        margin: 8px 0;
      }
      .user {
        color: #f472b6;
      }
      .staff {
        color: #4ade80;
      }
      .bot {
        color: #a78bfa;
      }
      .meta {
        color: #94a3b8;
        font-size: 12px;
      }
      .flex {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
      input,
      button {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid #1e293b;
        background: #0a1122;
        color: #e5e7eb;
      }
      input.grow {
        flex: 1;
      }
      button {
        background: #2563eb;
        border: 0;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="col">
        <h2>Tickets</h2>
        <div class="list" id="ticketList"></div>
      </div>
      <div class="col">
        <h2 id="threadTitle">Thread</h2>
        <div class="msgs" id="msgs"></div>
        <div class="flex">
          <input id="agentName" placeholder="Agent name" style="width: 160px" />
          <input
            id="chatInput"
            placeholder="Type a message…"
            class="grow"
            disabled
          />
          <button id="sendBtn" disabled>Send</button>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const $ = (id) => document.getElementById(id);
      const ticketList = $("ticketList");
      const msgs = $("msgs");
      const sendBtn = $("sendBtn");
      const chatInput = $("chatInput");
      const agentNameInput = $("agentName");
      const threadTitle = $("threadTitle");

      let socket;
      let activeTicketId = null;

      // Keep a short-lived buffer of our own sends so we can ignore the echoed chat:new
      const recentSelfSends = []; // items: {text, authorName, at}

      function el(tag, attrs = {}, children = []) {
        const n = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === "class") n.className = v;
          else if (k === "dataset")
            Object.entries(v).forEach(([dk, dv]) => (n.dataset[dk] = dv));
          else n.setAttribute(k, v);
        });
        children.forEach((c) =>
          typeof c === "string" ? (n.textContent = c) : n.appendChild(c)
        );
        return n;
      }
      function formatTime(d) {
        return new Date(d).toLocaleTimeString();
      }

      function rowForTicket(t) {
        const title = el("div", {}, [t.title || "(no title)"]);
        const muted1 = el("div", { class: "muted" }, [
          `${t.city || "Unknown"} • ${t.severity || "minor"} • ${t.status}`,
        ]);
        const snip = el("div", { class: "muted" }, [
          (t.lastMessageSnippet || "").slice(0, 100),
        ]);
        const count = el("span", { class: "count" }, [
          String(t.messageCount || 0),
        ]);
        const wrap = el("div", { class: "row", dataset: { ticketId: t._id } }, [
          title,
          muted1,
          snip,
          count,
        ]);
        wrap.onclick = () => openThread(t._id, t.title || "(no title)");
        return wrap;
      }

      function paintTickets(list) {
        ticketList.innerHTML = "";
        list.forEach((t) => ticketList.appendChild(rowForTicket(t)));
      }

      function selectActiveRow(id) {
        for (const r of ticketList.querySelectorAll(".row")) {
          r.classList.toggle("active", r.dataset.ticketId === id);
        }
      }

      function addMsg({ authorType, authorName, text, createdAt }) {
        const div = document.createElement("div");
        const roleClass = authorType || "user";
        div.className = `msg ${roleClass}`;
        div.innerHTML = `<div><strong>[${authorType}] ${
          authorName || ""
        }</strong> <span class="meta">${formatTime(
          createdAt || Date.now()
        )}</span></div><div>${escapeHtml(text)}</div>`;
        msgs.appendChild(div);
        msgs.scrollTop = msgs.scrollHeight;
      }

      function escapeHtml(s) {
        return (s || "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      async function fetchTickets() {
        const res = await fetch("/api/tickets");
        return res.ok ? res.json() : [];
      }

      async function loadThreadHistory(id) {
        const res = await fetch(`/api/tickets/${id}/chat`);
        const data = await res.json();
        if (data?.success) {
          msgs.innerHTML = "";
          data.messages.forEach(addMsg);
        } else {
          console.error("Thread history failed:", data);
        }
      }

      async function openThread(id, title) {
        activeTicketId = id;
        selectActiveRow(id);
        threadTitle.textContent = `Thread — ${title} (${id})`;
        chatInput.disabled = false;
        sendBtn.disabled = false;

        socket.emit("join", { ticketId: id }); // join ticket room
        await loadThreadHistory(id);
      }

      function pruneSelfBuffer() {
        const now = Date.now();
        // keep only the last ~2 seconds of entries
        for (let i = recentSelfSends.length - 1; i >= 0; i--) {
          if (now - recentSelfSends[i].at > 2000) recentSelfSends.splice(i, 1);
        }
      }

      async function sendStaffMessage() {
        const text = chatInput.value.trim();
        if (!text) return;
        if (!activeTicketId) {
          console.warn("No activeTicketId — open a ticket first.");
          return;
        }
        const authorName = agentNameInput.value.trim() || "Support";
        chatInput.value = "";

        // Optimistic render
        addMsg({ authorType: "staff", authorName, text });

        // Track our own send so we can ignore the echoed chat:new
        recentSelfSends.push({ text, authorName, at: Date.now() });
        pruneSelfBuffer();

        try {
          const res = await fetch(`/api/tickets/${activeTicketId}/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ authorType: "staff", authorName, text }),
          });
          if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            console.error("Staff send failed:", res.status, body);
            addMsg({
              authorType: "bot",
              authorName: "AutoBot",
              text: `⚠️ Failed to send (${res.status})`,
            });
          }
        } catch (e) {
          console.error("Staff network error:", e);
          addMsg({
            authorType: "bot",
            authorName: "AutoBot",
            text: "⚠️ Network error.",
          });
        }
      }

      sendBtn.onclick = sendStaffMessage;
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendStaffMessage();
        }
      });

      (async function init() {
        paintTickets(await fetchTickets());

        socket = io();
        socket.on("connect", () => {
          socket.emit("join", { role: "staff" }); // global staff room
        });

        socket.on("chat:new", (m) => {
          console.log("[staff chat:new]", m);
          if (String(m.ticketId) !== String(activeTicketId)) return;

          // If this is our own just-sent message, skip the echo (we already optimistically rendered it)
          if (m.authorType === "staff") {
            pruneSelfBuffer();
            const i = recentSelfSends.findIndex(
              (s) =>
                s.authorName === m.authorName &&
                s.text === m.text &&
                Math.abs(new Date(m.createdAt).getTime() - s.at) < 2000
            );
            if (i !== -1) {
              // matched our own recent send — ignore this echo
              recentSelfSends.splice(i, 1);
              return;
            }
          }

          addMsg(m);
        });

        socket.on("ticket:meta", ({ id, messageCount, lastMessageSnippet }) => {
          const r =
            ticketList.querySelector(`.row[data-ticket-id="${id}"]`) ||
            Array.from(ticketList.querySelectorAll(".row")).find(
              (el) => el.dataset.ticketId === String(id)
            );
          if (!r) {
            fetchTickets().then(paintTickets);
            return;
          }
          const countEl = r.querySelector(".count");
          if (countEl) countEl.textContent = String(messageCount || 0);
          const mutes = r.querySelectorAll(".muted");
          if (mutes[1])
            mutes[1].textContent = (lastMessageSnippet || "").slice(0, 100);
        });

        socket.on("ticket:created", async () =>
          paintTickets(await fetchTickets())
        );
        socket.on("ticket:closed", async () =>
          paintTickets(await fetchTickets())
        );
      })();
    </script>
  </body>
</html>
